// Code generated by "enumer -type=DType -yaml -json -text -values -output=gen_dtype_enumer.go gen_dtype_enum.go"; DO NOT EDIT.

package dtypes

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _DTypeName = "InvalidDTypeBoolInt8Int16Int32Int64Uint8Uint16Uint32Uint64Float16Float32Float64BFloat16Complex64Complex128F8E5M2F8E4M3FNF8E4M3B11FNUZF8E5M2FNUZF8E4M3FNUZS4U4TOKENS2U2F8E4M3F8E3M4F8E8M0FNUF4E2M1FN"

var _DTypeIndex = [...]uint8{0, 12, 16, 20, 25, 30, 35, 40, 46, 52, 58, 65, 72, 79, 87, 96, 106, 112, 120, 133, 143, 153, 155, 157, 162, 164, 166, 172, 178, 187, 195}

const _DTypeLowerName = "invaliddtypeboolint8int16int32int64uint8uint16uint32uint64float16float32float64bfloat16complex64complex128f8e5m2f8e4m3fnf8e4m3b11fnuzf8e5m2fnuzf8e4m3fnuzs4u4tokens2u2f8e4m3f8e3m4f8e8m0fnuf4e2m1fn"

func (i DType) String() string {
	if i < 0 || i >= DType(len(_DTypeIndex)-1) {
		return fmt.Sprintf("DType(%d)", i)
	}
	return _DTypeName[_DTypeIndex[i]:_DTypeIndex[i+1]]
}

func (DType) Values() []string {
	return DTypeStrings()
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DTypeNoOp() {
	var x [1]struct{}
	_ = x[InvalidDType-(0)]
	_ = x[Bool-(1)]
	_ = x[Int8-(2)]
	_ = x[Int16-(3)]
	_ = x[Int32-(4)]
	_ = x[Int64-(5)]
	_ = x[Uint8-(6)]
	_ = x[Uint16-(7)]
	_ = x[Uint32-(8)]
	_ = x[Uint64-(9)]
	_ = x[Float16-(10)]
	_ = x[Float32-(11)]
	_ = x[Float64-(12)]
	_ = x[BFloat16-(13)]
	_ = x[Complex64-(14)]
	_ = x[Complex128-(15)]
	_ = x[F8E5M2-(16)]
	_ = x[F8E4M3FN-(17)]
	_ = x[F8E4M3B11FNUZ-(18)]
	_ = x[F8E5M2FNUZ-(19)]
	_ = x[F8E4M3FNUZ-(20)]
	_ = x[S4-(21)]
	_ = x[U4-(22)]
	_ = x[TOKEN-(23)]
	_ = x[S2-(24)]
	_ = x[U2-(25)]
	_ = x[F8E4M3-(26)]
	_ = x[F8E3M4-(27)]
	_ = x[F8E8M0FNU-(28)]
	_ = x[F4E2M1FN-(29)]
}

var _DTypeValues = []DType{InvalidDType, Bool, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float16, Float32, Float64, BFloat16, Complex64, Complex128, F8E5M2, F8E4M3FN, F8E4M3B11FNUZ, F8E5M2FNUZ, F8E4M3FNUZ, S4, U4, TOKEN, S2, U2, F8E4M3, F8E3M4, F8E8M0FNU, F4E2M1FN}

var _DTypeNameToValueMap = map[string]DType{
	_DTypeName[0:12]:         InvalidDType,
	_DTypeLowerName[0:12]:    InvalidDType,
	_DTypeName[12:16]:        Bool,
	_DTypeLowerName[12:16]:   Bool,
	_DTypeName[16:20]:        Int8,
	_DTypeLowerName[16:20]:   Int8,
	_DTypeName[20:25]:        Int16,
	_DTypeLowerName[20:25]:   Int16,
	_DTypeName[25:30]:        Int32,
	_DTypeLowerName[25:30]:   Int32,
	_DTypeName[30:35]:        Int64,
	_DTypeLowerName[30:35]:   Int64,
	_DTypeName[35:40]:        Uint8,
	_DTypeLowerName[35:40]:   Uint8,
	_DTypeName[40:46]:        Uint16,
	_DTypeLowerName[40:46]:   Uint16,
	_DTypeName[46:52]:        Uint32,
	_DTypeLowerName[46:52]:   Uint32,
	_DTypeName[52:58]:        Uint64,
	_DTypeLowerName[52:58]:   Uint64,
	_DTypeName[58:65]:        Float16,
	_DTypeLowerName[58:65]:   Float16,
	_DTypeName[65:72]:        Float32,
	_DTypeLowerName[65:72]:   Float32,
	_DTypeName[72:79]:        Float64,
	_DTypeLowerName[72:79]:   Float64,
	_DTypeName[79:87]:        BFloat16,
	_DTypeLowerName[79:87]:   BFloat16,
	_DTypeName[87:96]:        Complex64,
	_DTypeLowerName[87:96]:   Complex64,
	_DTypeName[96:106]:       Complex128,
	_DTypeLowerName[96:106]:  Complex128,
	_DTypeName[106:112]:      F8E5M2,
	_DTypeLowerName[106:112]: F8E5M2,
	_DTypeName[112:120]:      F8E4M3FN,
	_DTypeLowerName[112:120]: F8E4M3FN,
	_DTypeName[120:133]:      F8E4M3B11FNUZ,
	_DTypeLowerName[120:133]: F8E4M3B11FNUZ,
	_DTypeName[133:143]:      F8E5M2FNUZ,
	_DTypeLowerName[133:143]: F8E5M2FNUZ,
	_DTypeName[143:153]:      F8E4M3FNUZ,
	_DTypeLowerName[143:153]: F8E4M3FNUZ,
	_DTypeName[153:155]:      S4,
	_DTypeLowerName[153:155]: S4,
	_DTypeName[155:157]:      U4,
	_DTypeLowerName[155:157]: U4,
	_DTypeName[157:162]:      TOKEN,
	_DTypeLowerName[157:162]: TOKEN,
	_DTypeName[162:164]:      S2,
	_DTypeLowerName[162:164]: S2,
	_DTypeName[164:166]:      U2,
	_DTypeLowerName[164:166]: U2,
	_DTypeName[166:172]:      F8E4M3,
	_DTypeLowerName[166:172]: F8E4M3,
	_DTypeName[172:178]:      F8E3M4,
	_DTypeLowerName[172:178]: F8E3M4,
	_DTypeName[178:187]:      F8E8M0FNU,
	_DTypeLowerName[178:187]: F8E8M0FNU,
	_DTypeName[187:195]:      F4E2M1FN,
	_DTypeLowerName[187:195]: F4E2M1FN,
}

var _DTypeNames = []string{
	_DTypeName[0:12],
	_DTypeName[12:16],
	_DTypeName[16:20],
	_DTypeName[20:25],
	_DTypeName[25:30],
	_DTypeName[30:35],
	_DTypeName[35:40],
	_DTypeName[40:46],
	_DTypeName[46:52],
	_DTypeName[52:58],
	_DTypeName[58:65],
	_DTypeName[65:72],
	_DTypeName[72:79],
	_DTypeName[79:87],
	_DTypeName[87:96],
	_DTypeName[96:106],
	_DTypeName[106:112],
	_DTypeName[112:120],
	_DTypeName[120:133],
	_DTypeName[133:143],
	_DTypeName[143:153],
	_DTypeName[153:155],
	_DTypeName[155:157],
	_DTypeName[157:162],
	_DTypeName[162:164],
	_DTypeName[164:166],
	_DTypeName[166:172],
	_DTypeName[172:178],
	_DTypeName[178:187],
	_DTypeName[187:195],
}

// DTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DTypeString(s string) (DType, error) {
	if val, ok := _DTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to DType values", s)
}

// DTypeValues returns all values of the enum
func DTypeValues() []DType {
	return _DTypeValues
}

// DTypeStrings returns a slice of all String values of the enum
func DTypeStrings() []string {
	strs := make([]string, len(_DTypeNames))
	copy(strs, _DTypeNames)
	return strs
}

// IsADType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i DType) IsADType() bool {
	for _, v := range _DTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for DType
func (i DType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DType
func (i *DType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("DType should be a string, got %s", data)
	}

	var err error
	*i, err = DTypeString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for DType
func (i DType) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DType
func (i *DType) UnmarshalText(text []byte) error {
	var err error
	*i, err = DTypeString(string(text))
	return err
}

// MarshalYAML implements a YAML Marshaler for DType
func (i DType) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for DType
func (i *DType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = DTypeString(s)
	return err
}
